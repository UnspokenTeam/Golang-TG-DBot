// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: play.sql

package querier

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getChatMemberCount = `-- name: GetChatMemberCount :one
SELECT COUNT(*)
FROM chat_users cu
WHERE cu.chat_tg_id = $1
`

func (q *Queries) GetChatMemberCount(ctx context.Context, chatTgID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getChatMemberCount, chatTgID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGameLastTime = `-- name: GetGameLastTime :one
SELECT c.last_c_game_at
FROM chats c
WHERE c.tg_id = $1
`

func (q *Queries) GetGameLastTime(ctx context.Context, tgID int64) (*time.Time, error) {
	row := q.db.QueryRow(ctx, getGameLastTime, tgID)
	var last_c_game_at *time.Time
	err := row.Scan(&last_c_game_at)
	return last_c_game_at, err
}

const getUsersForGameCursorBased = `-- name: GetUsersForGameCursorBased :many
SELECT
    u.user_name,
    cu.user_tg_id,
    cu.last_message_at
FROM chat_users cu
JOIN users u ON cu.user_tg_id = u.tg_id
WHERE cu.chat_tg_id = $1
  AND cu.is_user_removed = false
  AND (cu.last_message_at, cu.user_tg_id) < ($3, $4::bigint)
ORDER BY cu.last_message_at DESC, cu.user_tg_id DESC
LIMIT $2
`

type GetUsersForGameCursorBasedParams struct {
	ChatTgID       int64
	Limit          int32
	Cursor         time.Time
	TiebreakerTgID int64
}

type GetUsersForGameCursorBasedRow struct {
	UserName      string
	UserTgID      int64
	LastMessageAt time.Time
}

func (q *Queries) GetUsersForGameCursorBased(ctx context.Context, arg GetUsersForGameCursorBasedParams) ([]GetUsersForGameCursorBasedRow, error) {
	rows, err := q.db.Query(ctx, getUsersForGameCursorBased,
		arg.ChatTgID,
		arg.Limit,
		arg.Cursor,
		arg.TiebreakerTgID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersForGameCursorBasedRow{}
	for rows.Next() {
		var i GetUsersForGameCursorBasedRow
		if err := rows.Scan(&i.UserName, &i.UserTgID, &i.LastMessageAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordGame = `-- name: RecordGame :exec
UPDATE chat_users
SET
    games_played = games_played + 1
WHERE chat_tg_id = $1 AND user_tg_id = ANY($2::bigint[])
`

type RecordGameParams struct {
	ChatTgID int64
	Ids      []int64
}

func (q *Queries) RecordGame(ctx context.Context, arg RecordGameParams) error {
	_, err := q.db.Exec(ctx, recordGame, arg.ChatTgID, arg.Ids)
	return err
}

const recordGameLose = `-- name: RecordGameLose :exec
UPDATE chat_users
SET
    loses = loses + 1
WHERE chat_tg_id = $1 AND user_tg_id = $2
`

type RecordGameLoseParams struct {
	ChatTgID int64
	UserTgID int64
}

func (q *Queries) RecordGameLose(ctx context.Context, arg RecordGameLoseParams) error {
	_, err := q.db.Exec(ctx, recordGameLose, arg.ChatTgID, arg.UserTgID)
	return err
}

const removeLostUsers = `-- name: RemoveLostUsers :exec
UPDATE chat_users
SET
    is_user_removed = true
WHERE chat_tg_id = $1 AND user_tg_id = ANY($2::bigint[])
`

type RemoveLostUsersParams struct {
	ChatTgID int64
	Ids      []int64
}

func (q *Queries) RemoveLostUsers(ctx context.Context, arg RemoveLostUsersParams) error {
	_, err := q.db.Exec(ctx, removeLostUsers, arg.ChatTgID, arg.Ids)
	return err
}

const startGame = `-- name: StartGame :one
UPDATE chats
SET
    last_c_game_at = now()
WHERE tg_id = $1
  AND (last_c_game_at IS NULL OR last_c_game_at < NOW() - $2::interval)
RETURNING last_c_game_at
`

type StartGameParams struct {
	TgID     int64
	Cooldown pgtype.Interval
}

func (q *Queries) StartGame(ctx context.Context, arg StartGameParams) (*time.Time, error) {
	row := q.db.QueryRow(ctx, startGame, arg.TgID, arg.Cooldown)
	var last_c_game_at *time.Time
	err := row.Scan(&last_c_game_at)
	return last_c_game_at, err
}
